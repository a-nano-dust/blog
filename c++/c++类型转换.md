## c++ 强制类型转换

关于 c++ 类型转换的基本介绍，请查看《Primer c++ 第五版》一书中的 4.11.3 节和 19.2.1 节中的内容。本篇笔记中只对这些内容做归纳总结，并对其中不够清晰的地方做更进一步的解释。

##### 旧式的强制类型转换

所谓旧式的强制类型转换，就是 c++ 从 c 语言中继承而来的语法，它存在如下两种形式：

```c++
type (expr);	// 函数形式的强制类型转换
(type) expr;	// C语言风格的强制类型转换
```

根据所涉及的类型不同，旧式的强制类型转换分别具有与 const_cast 、 static_cast 或 reinterpret_cast 相似的行为。也就是说，旧式的强制类型转换功能更多、形式也更简单，那么为什么还需要再添加强制类型转换的语法呢？

《Primer c++ 第五版》一书中给出的答案是：**与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。**

##### 命名的强制类型转换

一个命名的强制类型转换具有如下形式：

```
cast-name<type>(expression);
```

其中，type 是转换的目标类型而 expression 是要转换的值。cast-name 是 static_cast 、 dynamic_cast 、const_cast 和 reinterpret_cast 中的一种。

- **static_cast：**任何具有明确定义的类型转换，只要不包含底层 const ，都可以使用它。static_cast 的使用场景极其广泛，大多数时候它都可以发挥作用。
- **dynamic_cast：**要求被转换值是指针或引用，对应的目标类型也是指针或引用，并且目标类型被限制必须是被转换值的父类或子类或与被转换值得类型相同。dynamic_cast 在运行时生效，如果转换指针失败，则返回0；如果转换引用失败，则抛出 bad_cast 异常。
- **const_cast：**可以为被转换得值添加或去掉 const 限定符。必须注意得是，它只能改变运算对象的底层 const 。如果被转换的值本身不是常量，该转换是合法的；如果被转换的值本身就是常量，该转换会导致未定义的的后果。const_cast 主要用于函数重载的参数传递场景中，选择合适的重载函数。
- **reinterpret_cast：**通常为运算对象的位模式提供较低层次上的重新解释。

从概念上看，reinterpret_cast 的作用难以从字面上进行理解，接下来我们对它做更深入的解释。我在网上看到一篇 [文章](https://www.cnblogs.com/ider/archive/2011/07/30/cpp_cast_operator_part3.html) ，对 reinterpret_cast 的作用进行了详细的解释，我们在此基础上进行归纳总结。

reinterpret_cast 所作的转换与类型无关，它并不会改变原值，而是从数据底层的每一个 bit ，按照要转换的类型，重新解释这些数据。因此从理论上讲，只要两个类型的内存结构具有相同数量的 bit ，就可以使用 reinterpret_cast 进行转换，但实际上却并非如此。在上述 [文章](https://www.cnblogs.com/ider/archive/2011/07/30/cpp_cast_operator_part3.html) 中列举了一些可以使用 reinterpret_cast 的场景：

- 从指针类型到一个足够大的整数类型；
- 从整数类型或者枚举类型到指针类型；
- 从一个指向函数的指针到另一个不同类型的指向函数的指针；
- 从一个指向对象的指针到另一个不同类型的指向对象的指针；
- 从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针；
- 从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针

实际上，**使用 reinterpret_cast 可以实现任意两种类型指针之间的相互转换，也可以实现任意类型指针与足够大的整数类型之间的相互转换。**

> 所谓"足够大的整数类型",取决于操作系统的参数，如果是32位的操作系统，就需要整形（int）以上的；如果是64位的操作系统，则至少需要长整形（long）。具体大小可以通过sizeof运算符来查看。

最后需要说明的是，reinterpret_cast 虽然看似功能强大，但使用场景却十分稀少，错误使用 reinterpret_cast 很容易导致程序不安全，因此也不推荐使用它。